#!/bin/bash
###############################################################################
# Description: The cross platform development toolkit - allmake
# Author: John Deng (john.deng@outlook.com)
# 
# Copyright (c) 2015 John Deng (john.deng@outlook.com)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
###############################################################################
# echo "allmake start ..."
###############################################################################
# TODOs: 
# allmake git [git command]
# allmake mvn [mvn command]
###############################################################################
# Basic Info

ALLMAKE_VER="1.0.2"
ALLMAKE_UPDATED="2016.04.17"
ALLMAKE_NAME=allmake
ALLMAKE_AUTHER="John Deng (john.deng@outlook.com)"
ALLMAKE_DES="Description: The cross platform development toolkit - ${ALLMAKE_NAME}"

###############################################################################
# Show version info
function showVersion()
{
    echo -e " $GREEN
            _|  _|                            _|                  
    _|_|_|  _|  _|  _|_|_|  _|_|      _|_|_|  _|  _|      _|_|    
  _|    _|  _|  _|  _|    _|    _|  _|    _|  _|_|      _|_|_|_|  
  _|    _|  _|  _|  _|    _|    _|  _|    _|  _|  _|    _|        
    _|_|_|  _|  _|  _|    _|    _|    _|_|_|  _|    _|    _|_|_|   V$ALLMAKE_VER
  
  $ALLMAKE_DES
  Author: $ALLMAKE_AUTHER
  Updated $ALLMAKE_UPDATED
  $ENDCOLOR"
}
###############################################################################
# Show help
function showHelp()
{
    showVersion

    echo -e "
Usage: the usage is as same as make but with more powerful features

options:
    add     : add a new platform
    update  : update settings
    clean   : clean objects
    plat    : specify platform name under toolchian, you may just type the key word instead of whole name, without this option, ${ALLMAKE_NAME} will make all platfroms.
    all     : make all source codes
    release : make release with O2 (optimization) option
    bin     : output binary, it will output shared library file (linux: .so, mac os x: .dylib, windows: .dll) without this option
    install : install target to \${ALLMAKE_HOME}/platfrom/
    plat    : specify platfrom, make single platform instead of all, e.g. ${ALLMAKE_NAME} clean all plat=x86
    options : options for third party source code, e.g. ${ALLMAKE_NAME} add plat=brcm options='--with-zlib --with-png '
    exports : export variables, e.g. allmake add plat=brcm export='cc' --> export CC=arm-brcm-linux-gnueabi-gcc
    cwd     : set current directory as working directoy
    app     : app name, e.g. app=myapp
    ver     : app version
    profile : profile [test, dev, prod]
    ports   : ports that need to redirect
    template: java or node
    inet    : network adapter interface, e.g. eth0

Examples:      
    ${ALLMAKE_NAME} add plat=x86
    ${ALLMAKE_NAME} update ver=1.0.1     
    ${ALLMAKE_NAME} plat=x86 uiclean ui
    ${ALLMAKE_NAME} plat=x86 clean
    ${ALLMAKE_NAME} plat=x86 clean all
    ${ALLMAKE_NAME} plat=x86 clean all install
    ${ALLMAKE_NAME} plat=x86 install
    ${ALLMAKE_NAME} plat=x86 clean all
    ${ALLMAKE_NAME} plat=x86 clean all bin
    ${ALLMAKE_NAME} plat=x86 clean all test
    ${ALLMAKE_NAME} add app=myapp ver=1.0.0 profile=test ports="8080 9090 9500" template=java inet=eth0
    ${ALLMAKE_NAME} docker up

    " 
}
###############################################################################
# string replacement
function replace()
{
    echo "${1/$2/$3}"
}

###############################################################################
# Show warning

function showWarning()
{
    echo ""
    echo -e "${YELLOW}[${ALLMAKE_NAME}] Warning..."
    echo "_________________________________________________________________________________________"
    echo ""
    while [ "$#" != "0" ]; do
        echo "$1"
        shift
    done
    echo "_________________________________________________________________________________________"
    echo -e "${ENDCOLOR}"        
}

###############################################################################
# Prompt Yes or No

function promptyesorno () 
{
    while true; do
        echo -e "${YELLOW}"
        read -p "$1 " yn < /dev/tty
        echo -e "${ENDCOLOR}"
        case $yn in
            [Yy]* ) return 0;;
            [Nn]* ) return 1;;
            * ) echo "Please answer yes or no.";;
        esac
    done
}

###############################################################################
# Init platform variables

function initPlat()
{
    # echo "check if we need to add $PLAT_NAME"
	if [ "$add" != "" ]; then
		# echo add: $add
		PLAT_BUILD_SCRIPT=Makefile
	    if [ "$CONFIG_CMD" != "" ]; then
	    	PLAT_BUILD_SCRIPT=build.sh
	    fi

	    # ask user to confirm if platform is exist
	    # echo PWD: $PWD
        # echo PLAT_BUILD_SCRIPT: $PLAT_BUILD_SCRIPT
	    if [ -f "$PWD/$PLAT_BUILD_SCRIPT" ]; then
	    	# echo "propmt warning exist ..."
	    	if promptyesorno "The platform $PLAT_NAME is already exist, do you wish to overwrie it with new configures? [yes/no]"; then
	    		#echo "Removing old and creating new Makefile ..."
			    rm -rf $PLAT_BUILD_SCRIPT
			else
                # echo -e "${YELLOW} Cancelled! ${ENDCOLOR}"
                # return 1
                quit
			fi
	    fi

        # create makefile for specifics platform
		if [ "$isThirdPartyProject" == "no" ]; then
            # echo "Replaced platform makefile"
			createPlatMakefile        
		fi
	fi

    if [ "$COMPILER" == "" ]; then
        COMPILER=$PLAT_NAME
    fi
    export TOOLCHAIN_DIR=$ALLMAKE_HOME/toolchain/$PLAT_NAME
    export COMPILER_BIN=$TOOLCHAIN_DIR/bin
    export PATH=$COMPILER_BIN:$PATH
    export PLAT_DIR=$ALLMAKE_HOME/platform/$PLAT_NAME

    export HOST_PREFIX=
    if [ -f "$COMPILER_BIN/${COMPILER}-gcc" ]; then
        export HOST_PREFIX=${COMPILER}-
    fi

    # echo $COMPILER_BIN/${COMPILER}-gcc-ar
    export HOST_PREFIX2=HOST_PREFIX
    export HOST_PREFIX_GCC=${HOST_PREFIX}gcc-
    # if [ -f "$COMPILER_BIN/${COMPILER}-gcc-ar" ]; then
    #     export HOST_PREFIX2=HOST_PREFIX_GCC
    # fi
    hasallcc=$(echo ${exports} | grep -i "allcc")
    #echo hasallcc: $hasallcc
    if [ "$hasallcc" != "" ]; then
        exports="${exports} cc cxx ld ranlib ar strip"
    fi

    EXPORT_CC=$(
        for exp in $exports
        do
            if [ "$exp" == "cc" ]; then
                echo "export CC=\${HOST_PREFIX}gcc"
            fi
            if [ "$exp" == "cxx" ]; then
                echo "export CXX=\${HOST_PREFIX}g++"
            fi
            if [ "$exp" == "ld" ]; then
                echo "export LD=\${HOST_PREFIX}ld"
            fi
            if [ "$exp" == "ranlib" ]; then
                echo "export RANLIB=\${HOST_PREFIX}ranlib"
            fi
            if [ "$exp" == "ar" ]; then
                echo "export AR=\${HOST_PREFIX}ar"
            fi
            if [ "$exp" == "strip" ]; then
                echo "export STRIP=\${HOST_PREFIX}strip"
            fi
            if [ "$exp" == "cflags" ]; then
                echo "export CFLAGS=\"-I\${PLAT_DIR}/include -I\${PLAT_DIR}/usr/include\""
            fi
            if [ "$exp" == "cppflags" ]; then
                echo "export CPPFLAGS=\"-I\${PLAT_DIR}/include -I\${PLAT_DIR}/usr/include\""
            fi
            if [ "$exp" == "ldflags" ]; then
                echo "export LDFLAGS=\"-I\${PLAT_DIR}/lib -I\${PLAT_DIR}/usr/lib\""
            fi

        done
        echo ""        
    )

    if [ "$cflags" != "" ]; then
        EXPORT_CC="${EXPORT_CC} 
export CFLAGS=$cflags"
    fi
    if [ "$cppflags" != "" ]; then
        EXPORT_CC="${EXPORT_CC} 
export CFLAGS=$cppflags"
    fi
    if [ "$cxxflags" != "" ]; then
        EXPORT_CC="${EXPORT_CC} 
export CFLAGS=$cxxflags"
    fi
    if [ "$ldflags" != "" ]; then
        EXPORT_CC="${EXPORT_CC} 
export CFLAGS=$ldflags"
    fi

    #echo EXPORT_CC: $EXPORT_CC

    # echo Platform $PLAT_NAME ...
    return 0
}

###############################################################################
# Create file .gitignore

function createGitIgnore()
{
cat > .gitignore <<_EOF_

*.o
obj/

_EOF_
}

###############################################################################
# Create file build.sh

function createThirdPartBuildScript()
{

# set platform directory as working directory
CONFIG_DIR="\$PROJECT_HOME/\$module"
WOKR_DIR="\$PWD"

# cwd - set current directory as working directory (the project home)
if [ "$cwd" != "" ]; then
    CONFIG_DIR="."
    WOKR_DIR="\$PWD/\$PROJECT_HOME/\$module"
fi

#echo $CONFIG_DIR
#echo $WOKR_DIR

MAKE_CONFIG=`echo $configure | grep -aobw make | grep -w 0`
HAS_MAKE_CONFIG=$?
MAKE=make
#echo HAS_MAKE_CONFIG: $HAS_MAKE_CONFIG
if [ $HAS_MAKE_CONFIG == 0 ]; then
	MAKE=$configure
fi
#echo MAKE: $MAKE

if [ "$prefix" == "" ]; then
    prefix=usr
fi
export prefix="\${PLAT_DIR}/${prefix}"
#echo prefix:$prefix
#echo cross: $cross
HOST_CONFIG=
if [ "$cross" != "" ]; then
    HOST_CONFIG="--host=\${PLAT_NAME}"
fi

options="$options $opt"

SHOW_CMD_LINE=$(echo ${CMD_LINE}" " | sed -e "s@options\(.*\)${SPACE}@options=\'$options\' @g" )
#echo SHOW_CMD_LINE: ${SHOW_CMD_LINE}

options=$(echo $options | sed -e "s@\$prefix@${prefix}@g" )
#echo options: $options

hasPrefixInOtions=$(echo "${options}" | grep '\-\-prefix' | wc -l)
#echo hasPrefixInOtions: $hasPrefixInOtions
OPT_PREFIX=
if [ "$hasPrefixInOtions" == "0" ]; then
    OPT_PREFIX="--prefix=$prefix"
fi

CONFIGURE=
if [ $HAS_MAKE_CONFIG == 1 ]; then
	CONFIGURE="${CONFIG_DIR}/${CONFIG_CMD} ${HOST_CONFIG} ${OPT_PREFIX} ${FLAGS_CFG} ${options}"
fi

echo ""
echo "Added platform $PLAT_NAME successfully!"
echo "$CONFIGURE"
echo ""
echo "Now you can run: "
echo ""
echo "    ${ALLMAKE_NAME} plat=$plat ${CONFIG_CMD}"
echo "    ${ALLMAKE_NAME} plat=$plat clean all install"
echo ""

cat > $1 <<_EOF_
#!/bin/bash
###############################################################################
# Description: ${BUILD_SH}
# Date & time: $(date +"%m-%d-%Y %H:%M")
# Author: $ALLMAKE_AUTHER
# Version: ${ALLMAKE_NAME} $ALLMAKE_VER
# Command line: ${CMD_LINE}
###############################################################################

$EXPORT_CC
pushd $WOKR_DIR > /dev/null

if [ "\$$CONFIG_CMD" != "" ]; then

	echo -e "\${DARKGREEN}configure ...\${ENDCOLOR}"
    
	$CONFIGURE
else
	$MAKE \$mt \$confclean \$distclean \$clean \$all \$uninstall \$install \$test
fi
popd > /dev/null
_EOF_
}

if [ ! -f ".gitignore" ]; then
    createGitIgnore
fi

###############################################################################
# Create file Makefile

function createCommonMakefile()
{
cat > Makefile <<_EOF_
###############################################################################
# Description: Common Makefile of ${ALLMAKE_NAME}
# NOTES: PLEASE DO NOT CHANGE THIS FILE
# Date & time: $(date +"%m-%d-%Y %H:%M")
# Author: $ALLMAKE_AUTHER
# Version: ${ALLMAKE_NAME} $ALLMAKE_VER
###############################################################################

ifeq ('\$(CXX_EXT)', '')
export CXX_EXT := cpp
endif

LIBNAME_PREFIX=lib
ifneq ('\$(NO_LIBNAME_PREFIX)', '')
    LIBNAME_PREFIX=
endif

export TARGET ?= \$(PROJECT_NAME)

CURR_DIR := \$(shell pwd)
ifeq ('\$(PLAT_NAME)', '')
    PLAT_NAME := \$(subst \$(dir \$(CURR_DIR)),\$(EMPTY),\$(CURR_DIR))
endif

PLAT_DIR := \$(ALLMAKE_HOME)/platform/\$(PLAT_NAME)

ifeq ('\$(INSTALL_INC_DIR_POSTFIX)', '')
    INSTALL_INC_DIR_POSTFIX = include/\$(PROJECT_NAME)
endif
INSTALL := install -p
INSTALL_DIR = \$(PLAT_DIR)\$(TARGET_PREFIX)
INSTALL_BIN_DIR := \$(INSTALL_DIR)/bin-debug
INSTALL_INC_DIR := \$(INSTALL_DIR)/\$(INSTALL_INC_DIR_POSTFIX)
INSTALL_LIB_DIR := \$(INSTALL_DIR)/lib-debug
ifneq ('\$(RELEASE)', '')
    INSTALL_LIB_DIR := \$(INSTALL_DIR)/lib
    INSTALL_BIN_DIR := \$(INSTALL_DIR)/bin
endif

ifneq ('\$(LIB_DIR)', '')
    INSTALL_LIB_DIR := \$(LIB_DIR)
endif

ifneq ('\$(BIN_DIR)', '')
    INSTALL_BIN_DIR := \$(BIN_DIR)
endif

ifneq ('\$(prefix)', '')
    INSTALL_BIN_DIR := \$(prefix)
    INSTALL_LIB_DIR := \$(prefix)
endif

INSTALL_EXEC := \$(INSTALL) -m 0755
INSTALL_DATA := \$(INSTALL) -m 0644
MKDIR := mkdir -p
RANLIB := ranlib
TO_INC := \$(PROJECT_HOME)/include/*
TO_LIB := \$(TARGET)

INSTALL_DEST_DIR := \$(INSTALL_BIN_DIR)
LIB_CFLAGS :=
LIB_LFLAGS :=

ifeq ('\$(OS)', '')
    export OS=Linux
endif

LFLAGS_LDL :=
ifeq ('\$(OS)', 'Linux')
    LFLAGS_LDL := -ldl -lpthread
endif
SRC_DIR_SEP := "/"
RPATH_LINK := -Wl,-rpath-link=\$(PLAT_DIR)/lib -Wl,-rpath-link=\$(PLAT_DIR)/usr/lib -Wl,-rpath-link=\$(PLAT_DIR)/usr/local/lib
ifeq ('\$(OS)', 'Darwin')
    RPATH_LINK :=
    SRC_DIR_SEP :=
endif

ifeq ('\$(BUILD_LIB)', 'yes')
    TARGET := \$(LIBNAME_PREFIX)\$(TARGET).\$(LIBEXT)

    LIB_CFLAGS := -shared -fPIC
    LIB_LFLAGS := -shared -Wl,-soname,\$(TARGET)
    ifeq ('\$(LIBEXT)', 'dylib')
        ifeq ('\$(GCC_VER)', '4.9')
            LIB_CFLAGS := -bundle -undefined dynamic_lookup
        else
            LIB_CFLAGS :=
        endif    
        LIB_LFLAGS := -dynamiclib
    else 
        ifeq ('\$(LIBEXT)', 'dll')
            LIB_CFLAGS :=
            LIB_LFLAGS := -Wl,--add-stdcall-alias -shared
        endif
    endif

    INSTALL_DEST_DIR := \$(INSTALL_LIB_DIR)
endif

COMPILER_HOME := \$(COMPILER_HOME)
ifneq ('\$(PLAT_NAME)', '')
    ifeq ('\$(COMPILER_NAME)', '')
        COMPILER_NAME := \$(PLAT_NAME)
    endif
    ifeq ('\$(COMPILER_HOME)', '')
        COMPILER_HOME := \$(ALLMAKE_HOME)/toolchain/\$(COMPILER_NAME)/bin
        ifeq ('\$(HOST_PREFIX)', '')
            HOST_PREFIX := \$(COMPILER_NAME)-
        endif
    endif
endif

ifeq ('\$(PREFIX)', '')
    export PREFIX := \${ALLMAKE_HOME}/platform/\${COMPILER_NAME}\${TARGET_PREFIX}
endif

PLAT_DIR2 := \$(shell echo \$(PLAT_DIR) | sed 's/\//\\\\\\//g' )
PARSED_INCS := \$(shell echo \$(COMMON_INCS_LUT) | sed -e 's/^/ /' | sed 's/ / -I\$(PLAT_DIR2)\/include\//g' )
PARSED_INCS := \$(PARSED_INCS) \$(shell echo \$(COMMON_INCS_LUT) | sed -e 's/^/ /' | sed 's/ / -I\$(PLAT_DIR2)\/usr\/include\//g' )
PARSED_INCS := \$(PARSED_INCS) \$(shell echo \$(COMMON_INCS_LUT) | sed -e 's/^/ /' | sed 's/ / -I\$(PLAT_DIR2)\/usr\/local\/include\//g' )

ifeq ('\$(SRC_DIR_NAME)', '')
export SRC_DIR_NAME := src
endif

ifneq ('\$(SRC)', '')
export SRC_DIR_NAME := \$(SRC)
endif

ifeq ("\$(USE_QT)", "yes")
	# define QT_VER, default is qt4
	QT_VER ?= 4

	# define QT_HOME
	QT_HOME ?= \$(ALLMAKE_HOME)/platform/\$(PLAT_NAME)/qt\$(QT_VER)
	QT_MKSPECS_DIR ?= linux-g++

	ifneq ("\$(QT_HOME)", "")
		QT_INC_DIR := \$(QT_HOME)/include
		QT_LIB_DIR := \$(QT_HOME)/lib
		QT_BIN_DIR := \$(QT_HOME)/bin
		QT_MKSPECS := \$(QT_HOME)/mkspecs/\$(QT_MKSPECS_DIR)
	else
		QT_MKSPECS ?= /usr/share/qt\$(QT_VER)/mkspecs/linux-g++
	endif

	ifeq ("\$(QT_CFLAGS)", "")
		QT_CFLAGS ?= -pipe -D_REENTRANT -DQXTGUI_LIBRARY -DQT_GUI_LIB -DQT_CORE_LIB -DQT_SHARED
		QT_LFLAGS ?= -Wl,-rpath-link=\$(QT_LIB_DIR)
	endif

    ifneq ('\$(BUILD_LIB)', 'yes')
        QT_CFLAGS := -fPIE \$(QT_CFLAGS)
    endif

    QT_BIN_DIR ?= /usr/lib/x86_64-linux-gnu/qt\$(QT_VER)/bin
	QT_INC_DIR ?= /usr/include/qt\$(QT_VER)
	QT_INCS ?= -I\$(QT_MKSPECS) -I\$(QT_INC_DIR) -I\$(QT_INC_DIR)/QtWidgets -I\$(QT_INC_DIR)/QtGui -I\$(QT_INC_DIR)/QtCore -I\$(QT_INC_DIR)/QtDeclarative -I\$(QT_INC_DIR)/QtWebKit -I\$(QT_INC_DIR)/QtScript -I\$(QT_INC_DIR)/QtNetwork -I\$(QT_INC_DIR)/QtQml -I\$(QT_INC_DIR)/QtQuick -I\$(QT_INC_DIR)/QtXml  -I\$(QT_INC_DIR)/QtQml -I\$(QT_INC_DIR)/QtQuick
	ifeq ('\$(QT_VER)', '4')
        QT_LIBS ?= -lQtGui -lQtCore -lQtDeclarative -lQtScript -lQtNetwork # -lQtWebKit
	else
		QT_LIBS ?= -lQt5Gui -lQt5Widgets -lQt5Core -lQt5Script -lQt5Network -lQt5Qml # -lQt5WebKit
    endif

endif

QT_LIB_DIR_DECLARE=
ifneq ("\$(QT_LIB_DIR)", "")
	QT_LIB_DIR_DECLARE=-L\$(QT_LIB_DIR)
endif

# export PATH := \$(COMPILER_HOME):\$(PATH)
export PROJECT_INCLUDES := -I. -I\$(PROJECT_HOME) -I\$(PROJECT_HOME)/\$(SRC_DIR_NAME) -I\$(PROJECT_HOME)/\$(SRC_DIR_NAME)/\$(IMPL_DIR) -I\$(PROJECT_HOME)/\$(SRC_DIR_NAME)/tests -I\$(PLAT_DIR)/include -I\$(PLAT_DIR)/usr/include -I\$(PROJECT_HOME)/include
export PROJECT_LIBRARIES := -L\$(PLAT_DIR)/lib -L\$(PLAT_DIR)/usr/lib -L\$(PLAT_DIR)/usr/local/lib \$(QT_LIB_DIR_DECLARE)
export PROJECT_CFLAGS := \$(COMMON_CFLAGS) \$(LIB_CFLAGS) \$(PLAT_CFLAGS) \$(ARGS_CFLAGS) \$(USER_CFLAGS) \$(QT_CFLAGS)
export PROJECT_LFLAGS := \$(COMMON_LFLAGS) \$(LIB_LFLAGS) \$(PLAT_LFLAGS) \$(ARGS_LFLAGS) \$(USER_LFLAGS) \$(QT_LFLAGS)
export SRC_DIR := \$(PROJECT_HOME)/\$(SRC_DIR_NAME)
export FILTER_OUT := \$(FILTER_OUT_MAIN_SRCS) \$(FILTER_OUT_SRCS)

###############################################################################
# definitions
###############################################################################
ifeq ("\$(HAS_HOST_PREFIX)", "no")
export HOST_PREFIX :=
endif

GCC_POSTFIX :=
ifneq ("\$(GCC_VER)", "")
GCC_POSTFIX := -\$(GCC_VER)
endif

CC = \$(HOST_PREFIX)gcc\$(GCC_POSTFIX)
ifeq ("\$(GCC)", "g++")
    CC = \$(HOST_PREFIX)g++\$(GCC_POSTFIX)
endif
CXX = \$(HOST_PREFIX)g++\$(GCC_POSTFIX)
AS = \$(HOST_PREFIX)as

LD = \$(HOST_PREFIX)gcc\$(GCC_POSTFIX)
AR = \$(HOST_PREFIX)ar\$(GCC_POSTFIX)
ST = \$(HOST_PREFIX)strip\$(GCC_POSTFIX)
RM = rm -rf
MKDIR = mkdir -p

MOC = \$(QT_BIN_DIR)/moc
UIC = \$(QT_BIN_DIR)/uic
RCC = \$(QT_BIN_DIR)/rcc

FILTER_OUT_DIRS :=
ifneq ('\$(IMPL_DIR)', '')
    FILTER_OUT_DIRS := \$(shell find \$(SRC_DIR)\$(SRC_DIR_SEP) -type d | grep -vw \$(IMPL_DIR) | grep -vw tests | sed 's/\.\.\///g' | sed 's/\$(SRC_DIR_NAME)\///g' )
    ifneq ('\$(FILTER_OUT_DIRS)', '')
        FILTER_OUT_DIRS := \$(filter-out '',\$(FILTER_OUT_DIRS))
        FILTER_OUT_DIRS := \$(shell echo \$(FILTER_OUT_DIRS) | sed -e 's/^/ /' | sed 's/ / | grep -vw /g' )
    endif
endif

OBJ_DIR := obj

C_SRCS := \$(shell find \$(SRC_DIR)\$(SRC_DIR_SEP) -name *.c \$(FILTER_OUT_DIRS) | sed 's/\.\.\///g' | sed 's/\$(SRC_DIR_NAME)\///g')
# filter out specifics source files
ifneq ('\$(FILTER_OUT)', '')
	C_SRCS := \$(filter-out \$(FILTER_OUT),\$(C_SRCS))
endif
ifneq ('\$(FILTER)', '')
	C_SRCS := \$(filter \$(FILTER),\$(C_SRCS))
endif
C_OBJS := \$(patsubst %.c,\$(OBJ_DIR)/%.o,\$(C_SRCS))

CXX_SRCS := \$(shell find \$(SRC_DIR)\$(SRC_DIR_SEP) -name *.cpp \$(FILTER_OUT_DIRS) | sed 's/\.\.\///g' | sed 's/\$(SRC_DIR_NAME)\///g')
# filter out specifics source files
ifneq ('\$(FILTER_OUT)', '')
	CXX_SRCS := \$(filter-out \$(FILTER_OUT),\$(CXX_SRCS))
endif
ifneq ('\$(FILTER)', '')
	CXX_SRCS := \$(filter \$(FILTER),\$(CXX_SRCS))
endif
CXX_OBJS := \$(patsubst %.cpp,\$(OBJ_DIR)/%.o,\$(CXX_SRCS))

CC_SRCS := \$(shell find \$(SRC_DIR)\$(SRC_DIR_SEP) -name *.cc \$(FILTER_OUT_DIRS) | sed 's/\.\.\///g' | sed 's/\$(SRC_DIR_NAME)\///g')
# filter out specifics source files
ifneq ('\$(FILTER_OUT)', '')
	CC_SRCS := \$(filter-out \$(FILTER_OUT),\$(CC_SRCS))
endif
ifneq ('\$(FILTER)', '')
	CC_SRCS := \$(filter \$(FILTER),\$(CC_SRCS))
endif
CC_OBJS := \$(patsubst %.cc,\$(OBJ_DIR)/%.o,\$(CC_SRCS))

A_SRCS := \$(shell find \$(SRC_DIR)\$(SRC_DIR_SEP) -name *.asm \$(FILTER_OUT_DIRS) | sed 's/\.\.\///g' | sed 's/\$(SRC_DIR_NAME)\///g')
# filter out specifics source files
ifneq ('\$(FILTER_OUT)', '')
	A_SRCS := \$(filter-out \$(FILTER_OUT),\$(A_SRCS))
endif
ifneq ('\$(FILTER)', '')
	A_SRCS := \$(filter \$(FILTER),\$(A_SRCS))
endif
A_OBJS := \$(patsubst %.asm,\$(OBJ_DIR)/%.o,\$(A_SRCS))

Q_SRCS := \$(shell find \$(SRC_DIR)\$(SRC_DIR_SEP) -name *.ui \$(FILTER_OUT_DIRS) | sed 's/\.\.\///g' | sed 's/\$(SRC_DIR_NAME)\///g')
# filter out specifics source files
ifneq ('\$(FILTER_OUT)', '')
	Q_SRCS := \$(filter-out \$(FILTER_OUT),\$(Q_SRCS))
endif
ifneq ('\$(FILTER)', '')
	Q_SRCS := \$(filter \$(FILTER),\$(Q_SRCS))
endif
Q_UICS := \$(patsubst %.ui,\$(SRC_DIR)/ui_%.h,\$(Q_SRCS))
Q_MOCS := \$(patsubst %.ui,\$(SRC_DIR)/%_moc.cpp,\$(Q_SRCS))

ifeq ('\$(Q_SRCS)', '')
    Q_SRCS := \$(shell find \$(SRC_DIR)\$(SRC_DIR_SEP) -name '*.h' -exec grep -r "Q_OBJECT" {} \; -print | grep \/ | sed 's/\.\.\///g' | sed 's/\$(SRC_DIR_NAME)\///g' )
    Q_MOCS := \$(patsubst %.h,\$(SRC_DIR)/%_moc.cpp,\$(Q_SRCS))
endif

ifeq ('\$(Q_SRCS)', '')
    Q_SRCS := \$(shell find \$(PROJECT_HOME)/include\$(SRC_DIR_SEP) -name '*.h' -exec grep -r "Q_OBJECT" {} \; -print | grep \/ | sed 's/\.\.\///g' | sed 's/include\///g' )
    Q_MOCS := \$(patsubst %.h,\$(SRC_DIR)/%_moc.cpp,\$(Q_SRCS))
endif

Q_QRCS := \$(shell find \$(SRC_DIR)\$(SRC_DIR_SEP) -name *.qrc \$(FILTER_OUT_DIRS) | sed 's/\.\.\///g' | sed 's/\$(SRC_DIR_NAME)\///g')
ifneq ('\$(FILTER_OUT)', '')
	Q_QRCS := \$(filter-out \$(FILTER_OUT),\$(Q_QRCS))
endif
ifneq ('\$(FILTER)', '')
	Q_QRCS := \$(filter \$(FILTER),\$(Q_QRCS))
endif
Q_RCCS := \$(patsubst %.qrc,\$(SRC_DIR)/%_qrc.cpp,\$(Q_QRCS))

ifneq ('\$(CXX_OBJS)', '')
    LD = \$(HOST_PREFIX)g++\$(GCC_POSTFIX)
endif

ifneq ('\$(CC_OBJS)', '')
    LD = \$(HOST_PREFIX)g++\$(GCC_POSTFIX)
endif

INCLUDES = -I./include \$(PROJECT_INCLUDES) \$(COMMON_INCS) \$(PLAT_INCS) \$(USER_INCS) \$(PARSED_INCS) \$(QT_INCS)
LIBS = \$(PROJECT_LIBRARIES) \$(COMMON_LIBS) \$(PLAT_LIBS) \$(USER_LIBS) -lm \$(LFLAGS_LDL) \$(QT_LIBS)
CFLAGS = -Wall \$(PROJECT_CFLAGS) -c \$(INCLUDES)
LFLAGS = -Wall \$(PROJECT_LFLAGS) \$(RPATH_LINK)

SHELL=/bin/bash

COLOR_SUBST := | sed -e 's/error/\\\\\$(E_DARKRED)error\\\\\$(E_ENDCOLOR)/g' \\
               | sed -e 's/fatal/\\\\\$(E_DARKRED)fatal\\\\\$(E_ENDCOLOR)/g' \\
               | sed -e 's/warning/\\\\\$(E_DARKYELLOW)warning\\\\\$(E_ENDCOLOR)/g' \\
               | sed -e 's/警告/\\\\\$(E_DARKYELLOW)警告\\\\\$(E_ENDCOLOR)/g' \\
               | sed -e 's/undefined/\\\\\$(E_DARKRED)undefined\\\\\$(E_ENDCOLOR)/g' \\
               | sed -e 's/未定义的引用/\\\\\$(E_DARKRED)未定义的引用\\\\\$(E_ENDCOLOR)/g' \\
               | sed -e 's/not found/\\\\\$(E_DARKRED)not found\\\\\$(E_ENDCOLOR)/g' \\
               | sed -e 's/No such file or directory/\\\\\$(E_DARKRED)No such file or directory\\\\\$(E_ENDCOLOR)/g' \\
               | sed -e 's/cannot find/\\\\\$(E_DARKRED)cannot find\\\\\$(E_ENDCOLOR)/g' \\
               | sed -e 's/Error/\\\\\$(E_DARKRED)Error\\\\\$(E_ENDCOLOR)/g' \\
               | sed -e 's/错误/\\\\\$(E_DARKRED)错误\\\\\$(E_ENDCOLOR)/g' \\
               | sed -e 's/ERROR/\\\\\$(E_DARKRED)ERROR\\\\\$(E_ENDCOLOR)/g'

PRINT_COMPILE=@echo -e "\$(GREEN)\# Compiling \$< \$@ ... \$(ENDCOLOR)"
C_COMPILE=\$(CC) \$(CFLAGS) \$< -o \$@
C_COMPILE_OUT=\$\$(\$(C_COMPILE) 2>&1 \$(COLOR_SUBST) )

CXX_COMPILE=\$(CXX) \$(CFLAGS) \$< -o \$@
CXX_COMPILE_OUT=\$\$(\$(CXX_COMPILE) 2>&1 \$(COLOR_SUBST) )

A_COMPILE=\$(AS) \$< -o \$@
A_COMPILE_OUT=\$\$(\$(A_COMPILE) 2>&1 \$(COLOR_SUBST) )

QUIC_COMPILE=\$(UIC) \$< -o \$@
QUIC_COMPILE_OUT=\$\$(\$(QUIC_COMPILE) 2>&1 \$(COLOR_SUBST) )

QMOC_COMPILE=\$(MOC) \$(DEFINES) \$(INCPATH) \$< -o \$@
QMOC_COMPILE_OUT=\$\$(\$(QMOC_COMPILE) 2>&1 \$(COLOR_SUBST) )

QRCC_COMPILE=\$(RCC) -name res\$(PROJECT_NAME) \$< -o \$@
QRCC_COMPILE_OUT=\$\$(\$(QRCC_COMPILE) 2>&1 \$(COLOR_SUBST) )

PRINT_COMPILED=@echo -e "\$(BLUE)\# Compiled \$^ \$< \$@ ... \$(ENDCOLOR)"

PRINT_LINK=@echo -e "\$(BLUE)\# Linking \$^ \$< \$@ ... \$(ENDCOLOR)"
LINK=\$(LD) \$(LFLAGS) \$^ \$(LIBS) -o \$(OBJ_DIR)/\$@
LINK_OUT=\$\$(\$(LINK) 2>&1 \$(COLOR_SUBST))

COPY_CMD=
ifeq ('\$(NO_INCLUDE_INSTALL)', '')
    COPY_CMD=cp -r \$(TO_INC) \$(INSTALL_INC_DIR)
    ifneq ('\$(plat)', '')
        ifneq ('\$(DEVICE_PATH)', '')
            COPY_CMD=\$(COPY_CMD) && scp \$(OBJ_DIR)/\$(TARGET) \$(DEVICE_PATH)
        endif
    endif
endif
COPY_CMD_OUT=\$\$(\$(COPY_CMD) 2>&1 \$(COLOR_SUBST))

INSTALL_CMD=\$(INSTALL_EXEC) \$(OBJ_DIR)/\$(TARGET) \$(INSTALL_DEST_DIR)
INSTALL_CMD_OUT=\$\$(\$(INSTALL_CMD) 2>&1 \$(COLOR_SUBST))

###############################################################################
# build scripts
###############################################################################

.PHONY: all clean distclean

all: \$(TARGET)

\$(TARGET): \$(CXX_OBJS) \$(C_OBJS) \$(A_OBJS) \$(CC_OBJS)
	\$(PRINT_LINK)
	@echo -e "\$(LINK)\n\$(LINK_OUT)"

\$(OBJ_DIR)/%.o: \$(SRC_DIR)/%.c
	@\$(MKDIR) \$(dir \$@)
	\$(PRINT_COMPILE)
	@echo -e "\$(C_COMPILE)\$(C_COMPILE_OUT)"

\$(OBJ_DIR)/%.o: \$(SRC_DIR)/%.cpp
	@\$(MKDIR) \$(dir \$@)
	\$(PRINT_COMPILE)
	@echo -e "\$(CXX_COMPILE)\$(CXX_COMPILE_OUT)"

\$(OBJ_DIR)/%.o: \$(SRC_DIR)/%.cc
	@\$(MKDIR) \$(dir \$@)
	\$(PRINT_COMPILE)
	@echo -e "\$(CXX_COMPILE)\$(CXX_COMPILE_OUT)"

\$(OBJ_DIR)/%.o: \$(SRC_DIR)/%.asm
	@\$(MKDIR) \$(dir \$@)
	\$(PRINT_COMPILE)
	@echo -e "\$(A_COMPILE)\$(A_COMPILE_OUT)"

ui: \$(Q_MOCS) \$(Q_UICS) \$(Q_RCCS)
	\$(PRINT_COMPILED)

\$(SRC_DIR)/ui_%.h: \$(SRC_DIR)/%.ui
	\$(PRINT_COMPILE)
	@echo -e "\$(QUIC_COMPILE)\$(QUIC_COMPILE_OUT)"

\$(SRC_DIR)/%_moc.cpp: \$(SRC_DIR)/%.h
	@\$(MKDIR) \$(dir \$@)
	\$(PRINT_COMPILE)
	@echo -e "\$(QMOC_COMPILE)\$(QMOC_COMPILE_OUT)"

\$(SRC_DIR)/%_moc.cpp: \$(PROJECT_HOME)/include/%.h
	@\$(MKDIR) \$(dir \$@)
	\$(PRINT_COMPILE)
	@echo -e "\$(QMOC_COMPILE)\$(QMOC_COMPILE_OUT)"

\$(SRC_DIR)/%_qrc.cpp: \$(SRC_DIR)/%.qrc
	@\$(MKDIR) \$(dir \$@)
	\$(PRINT_COMPILE)
	@echo -e "\$(QRCC_COMPILE)\$(QRCC_COMPILE_OUT)"

configure:
	../../configure --host=\${COMPILER_NAME} --prefix=\${PREFIX}

uiclean:
	@echo -e QT_MKSPECS: \$(QT_MKSPECS)
	\$(RM) \$(Q_UICS) \$(Q_MOCS) \$(Q_RCCS)

clean:
	@echo -e cleaning: \$(FILTER_OUT)
	\$(RM) \$(OBJ_DIR) \$(CC_OBJS) \$(CXX_OBJS) \$(C_OBJS) \$(A_OBJS)

distclean: clean
	\$(RM) \$(OBJ_DIR) \$(BIN_DIR)/\$(TARGET)

install:
	\$(MKDIR) \$(INSTALL_BIN_DIR) \$(INSTALL_INC_DIR) \$(INSTALL_LIB_DIR)
	@echo -e "\$(COPY_CMD)\$(COPY_CMD_OUT)"
	\$(MKDIR) \$(INSTALL_LIB_DIR)
	@echo -e "\$(INSTALL_CMD)\$(INSTALL_CMD_OUT)"

ifneq "\$(MAKECMDGOALS)" "distclean"
ifneq "\$(MAKECMDGOALS)" "clean"
-include \$(DEPS)
endif
endif
_EOF_
}

###############################################################################
# Create file tests/test${name}.cpp

function createSourceCode()
{

if [ "$test" != ""  ]; then
    sourceFileName=./$SRC_DIR_NAME/tests/test${S_PROJECT_NAME}.$SRC_EXT
    if [ "$test" != "test"  ]; then
        # hasPrefix=`echo $test | grep -c "test"`
        # if [ "$hasPrefix" == "0" ]; then
        #     test=test${test}
        # fi
        hasExt=`echo $test | grep -c ".c"`
        #echo hasExt: $hasExt
        if [ "$hasExt" == "0" ]; then
            test=${test}.$SRC_EXT
        fi
        #echo "##########################################""
        sourceFileName=./$SRC_DIR_NAME/tests/$test
    fi
else
    if [ ! -f ./$SRC_DIR_NAME/main.$SRC_EXT ]; then
        sourceFileName=./$SRC_DIR_NAME/main.$SRC_EXT
    else
        return 0
    fi
fi

if [ -f $sourceFileName ]; then
    if promptyesorno "The file $sourceFileName is already exist, replace it? [yes/no]"; then
        echo "Replaced file: $sourceFileName"
    else
        return 1
    fi
# else    
#     echo "Added new file: $sourceFileName"
fi

#echo SRC_EXT: $SRC_EXT
if [ "$SRC_EXT" == "c" ]; then
    cat > ${sourceFileName} <<_EOF_
///////////////////////////////////////////////////////////////////////////////
// Project: $PROJECT_NAME
// Date & time: $(date +"%m-%d-%Y %H:%M")
// File created by: $user
///////////////////////////////////////////////////////////////////////////////

#include <stdlib.h>
#include <stdio.h>
#include <version.h>

int main(int argc, char* argv[])
{
    printf("%s\n", ${S_PROJECT_NAME}Version());
    return 0;
}

_EOF_

else

    cat > ${sourceFileName} <<_EOF_
///////////////////////////////////////////////////////////////////////////////
// Project: $PROJECT_NAME
// Date & time: $(date +"%m-%d-%Y %H:%M")
// File created by: $user
///////////////////////////////////////////////////////////////////////////////

#include <iostream>
#include <version.h>

using namespace std;

int main(int argc, char* argv[])
{
	cout << ${S_PROJECT_NAME}Version() << endl;
	return 0;
}

_EOF_

fi

if [ -f ./build/Makefile ]; then
    return 2
else
    return 0
fi
}


###############################################################################
# Create file src/dllmain.cpp

function createWinApi()
{

if [ "$winapi" != ""  ]; then
cat > ./src/winapi.h <<_EOF_
///////////////////////////////////////////////////////////////////////////////
// Project: $PROJECT_NAME
// Date & time: $(date +"%m-%d-%Y %H:%M")
// File created by: $user
///////////////////////////////////////////////////////////////////////////////

#ifndef WINAPI_H
#define WINAPI_H

#if defined(_WIN32) || defined(_WIN64)
#define API_EXPORT(t) __declspec (dllexport) t __stdcall
#else
#define API_EXPORT(t) t
#endif

#ifdef __cplusplus
extern "C"
{
#endif

// win api examples
// API_EXPORT(bool) ${PROJECT_NAME}_ready();

#ifdef __cplusplus
}
#endif

#endif // WINAPI_H

_EOF_

# winapi.cpp

cat > ./$SRC_DIR_NAME/winapi.$SRC_EXT <<_EOF_
///////////////////////////////////////////////////////////////////////////////
// Project: $PROJECT_NAME
// Date & time: $(date +"%m-%d-%Y %H:%M")
// File created by: $user
///////////////////////////////////////////////////////////////////////////////

#include <winapi.h>
#if defined(_WIN32) || defined(_WIN64)
#include <windows.h>

#ifdef __cplusplus
extern "C"
{
#endif

    API_EXPORT(BOOL) DllMain(HANDLE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)
    {
        switch (ul_reason_for_call)
        {
            case DLL_PROCESS_ATTACH:
                    break;
            case DLL_THREAD_ATTACH:
                    break;
            case DLL_THREAD_DETACH:
                    break;
            case DLL_PROCESS_DETACH:
                    break;
        }
        return TRUE;
    }
    
#ifdef __cplusplus
}
#endif

#endif  
_EOF_

fi
}
###############################################################################
# Create file include/version.h and src/version.cpp ( or src/version.c depending on ext=c )

function createVersionSource()
{

#echo "createVersionSource() $1"

updateVersion=$1    
if [ "$updateVersion" == "yes"   ]; then

cat > src/version.$SRC_EXT <<_EOF_
///////////////////////////////////////////////////////////////////////////////
// Project: $PROJECT_NAME
// Date & time: $(date +"%m-%d-%Y %H:%M")
// Author: John Deng
// Last change done by $Author: $user $
///////////////////////////////////////////////////////////////////////////////

#include "version.h"

static const char* s_pszVersion = "${S_PROJECT_NAME}${SPACE}V" REVERSION ".$dateTime";

const char* ${S_PROJECT_NAME}Version()
{
    return s_pszVersion;
}

_EOF_

cat > include/version.h <<_EOF_
///////////////////////////////////////////////////////////////////////////////
// Project: $PROJECT_NAME
// Date & time: $(date +"%m-%d-%Y %H:%M")
// Author: John Deng
// Last change done by $Author: $user $
///////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C"
{
#endif

const char* ${S_PROJECT_NAME}Version();

#ifdef __cplusplus
};
#endif

_EOF_

fi    
}

###############################################################################
# Create build/Makefile

function createBuildMakefile()
{
cat > Makefile <<_EOF_
###############################################################################
# Description: Common Project Makefile
# Date & time: $(date +"%m-%d-%Y %H:%M")
# Author: $ALLMAKE_AUTHER
# Version: ${ALLMAKE_NAME} $ALLMAKE_VER
# Command line: ${CMD_LINE}
###############################################################################

# TODO: add customize flags / include / lib below
export REVERSION ?= \"$ver\"
export COMMON_INCS_LUT := ${COMMON_INCS_LUT}
export COMMON_INCS := ${COMMON_INCS}
export COMMON_LIBS := ${COMMON_LIBS}
export COMMON_CFLAGS := ${COMMON_CFLAGS} -DREVERSION=\$(REVERSION)
export COMMON_LFLAGS := ${COMMON_LFLAGS}
export FILTER_OUT_SRCS :=
${EXPORT_USE_QT}
###############################################################################
# call makefile
###############################################################################

.PHONY: all

all:
	@echo \$(ECHO_OPTION_E) "\$(GREEN)# Compiling \$(PLAT_NAME) (target: \$(PROJECT_NAME)) ...\$(ENDCOLOR)"
	\$(MAKE) -f \$(PROJECT_HOME)/Makefile

configure:
	\$(MAKE) -f \$(PROJECT_HOME)/Makefile configure

ui:
	@echo \$(ECHO_OPTION_E) "\$(GREEN)# Compiling UI \$(PLAT_NAME) (target: \$(PROJECT_NAME)) ...\$(ENDCOLOR)"
	\$(MAKE) -f \$(PROJECT_HOME)/Makefile ui

install:
	@echo \$(ECHO_OPTION_E) "\$(TEAL)# Installing \$(PLAT_NAME) (target: \$(PROJECT_NAME)) ...\$(ENDCOLOR)"
	\$(MAKE) -f \$(PROJECT_HOME)/Makefile install

clean:
	@echo \$(ECHO_OPTION_E) "\$(YELLOW)# Cleaning \$(PLAT_NAME) (target: \$(PROJECT_NAME)) ...\$(ENDCOLOR)"
	\$(MAKE) -f \$(PROJECT_HOME)/Makefile clean

uiclean:
	@echo \$(ECHO_OPTION_E) "\$(YELLOW)# Cleaning UI sources \$(PLAT_NAME) (target: \$(PROJECT_NAME)) ...\$(ENDCOLOR)"
	\$(MAKE) -f \$(PROJECT_HOME)/Makefile uiclean

_EOF_
}

###############################################################################
# Create file build/{platform}/Makefile

function createPlatMakefile()
{
cat > Makefile <<_EOF_
###############################################################################
# Description: Platform Makefile
# Date & time: $(date +"%m-%d-%Y %H:%M")
# Author: $ALLMAKE_AUTHER
# Version: ${ALLMAKE_NAME} $ALLMAKE_VER
###############################################################################

###############################################################################
# definitions
###############################################################################
export COMPILER_HOME := ${COMPILER_HOME}
export HOST_PREFIX := ${HOST_PREFIX}
export PLAT_INCS := ${PLAT_INCS}
export PLAT_LIBS := ${PLAT_LIBS}
export PLAT_CFLAGS := ${PLAT_CFLAGS}
export PLAT_LFLAGS := ${PLAT_LFLAGS}
${EXPORT_QT_HOME}
${EXPORT_QT_MKSPECS}
${EXPORT_QT_VER}
###############################################################################
# call makefile
###############################################################################

.PHONY: all

all:
	\$(MAKE) -f ../Makefile

configure:
	\$(MAKE) -f ../Makefile configure

ui:
	\$(MAKE) -f ../Makefile ui

install:
	\$(MAKE) -f ../Makefile install

clean:
	\$(MAKE) -f ../Makefile clean

uiclean:
	\$(MAKE) -f ../Makefile uiclean

_EOF_
}

###############################################################################
# Build third party project

function buildThirdPart()
{
    #echo "Third party source"
	if [ "$add" != "" ] || [ "$start" != "" ]; then
		createThirdPartBuildScript "build.sh"
		exit
	fi

	bash $BUILD_SH
}


###############################################################################
# Build specifics platform

function build()
{
	# echo "build() $1"
    if [ ! -d $1 ]; then
        if [ "$add" == "" ]; then
            # if [ "$plat" != "" ]; then
            #     showWarning "You arm running ${ALLMAKE_NAME} for the platform ($1) that does not exist." "Please run ${ALLMAKE_NAME} add plat=your-platform-name first."            
            # fi
            #echo "exit ..."
            return
        else
            mkdir -p $1
        fi    
    fi
    PLAT_DIR=$1

    pushd $PLAT_DIR > /dev/null

    export PLAT_NAME=${PWD##*/}

    export HAS_HOST_PREFIX=no
    if [ -f $TOOLCHAIN_DIR/$PLAT_NAME/bin/$PLAT_NAME-gcc ]; then
        export HAS_HOST_PREFIX=yes
    fi
    #echo HAS_HOST_PREFIX $HAS_HOST_PREFIX
    case "$OSTYPE" in
        darwin*)
            export LIBEXT=dylib
        ;;
        msys*)
            export LIBEXT=dll
            export NO_LIBNAME_PREFIX=yes
        ;;
        linux*)
            export LIBEXT=so
        ;;
        *)
            export LIBEXT=so
        ;;
    esac

    # echo PLAT_NAME: $PLAT_NAME, $LIB_EXT
    if [ "$PLAT_NAME" != "" ]; then
        echo -e "${DARKGRAY}"
        echo "_________________________________________________________________________________________"
        echo ""
        echo " $ALLMAKE_DES V$ALLMAKE_VER"
        echo " Project: $PROJECT_NAME"
        if [ "${isThirdPartyProject}" == "yes" ]; then
            echo " Third party: $isThirdPartyProject"
        fi
        echo " OS: $OS" 
        echo " Platform: $plat $release"
        if [ "${isThirdPartyProject}" == "no" ]; then
            echo " Command line: make $LARGS"
        fi
        echo " Toolchain: $PLAT_NAME"
        echo " Output type: $OUTPUT_TYPE $TARGET"
        echo " Author: $ALLMAKE_AUTHER"
        echo "_________________________________________________________________________________________"
        echo -e "${ENDCOLOR}"

        initPlat
        res=$?
        # echo "after initPlat, res: $res"
        if [ $res != 0 ]; then
            # echo -e "$RED Init returned $res! $ENDCOLOR"
            return $res
            quit
        fi 

		if [ "${isThirdPartyProject}" == "yes" ]; then
			buildThirdPart
		else 
            if [ "$add" == "" ]; then
                #echo "make ... "
                make -s $mt ARGS_CFLAGS="${CUSTOM_CFLAGS}" ARGS_LFLAGS="${CUSTOM_LFLAGS}" $distclean $clean $all $install $print $uiclean $ui
            else
                echo ""    
                echo "Added platform $PLAT_NAME successfully!"
                echo ""
                echo "Now you can run: "
                echo ""
                echo "    ${ALLMAKE_NAME} plat=$plat clean all install"
                echo ""

            fi
        fi
    fi

    popd > /dev/null

    return 0
}

###############################################################################
# Build loop

function buildall()
{
    # filter out source code files that contains main function, also replace '\n' with space.
    export FILTER_OUT_MAIN_SRCS=`echo $1 | xargs | sed "s/ ---- /\n---- /g"`
    #echo "buildall():"
    # echo $#: $FILTER_OUT_MAIN_SRCS

    if [ "$plat" != "" ]; then
    	PLAT_COUNT=`find $TOOLCHAIN_DIR/ -maxdepth 1 -type d | grep $plat | wc -l`
    	#echo "PLAT_COUNT: $PLAT_COUNT"
    	if [ "$PLAT_COUNT" == "0" ]; then
            showWarning "The platform $plat is not found!" "Please check it in $TOOLCHAIN_DIR/"
    		exit
    	fi
	fi

    find ./ -maxdepth $maxdepth -type d -name "build" | while read builders; do
    	# echo builders:$builders
        pushd $builders > /dev/null

        if [ "$add" != "" ] && [ "$isThirdPartyProject" == "no" ]; then
        	#echo "add ..."
            if [ ! -f $PWD/Makefile ] || [ "${COMMON_INCS}${COMMON_LIBS}${COMMON_CFLAGS}${COMMON_LFLAGS}" != ""  ]; then
                #echo "Replaced build makefile"
                createBuildMakefile
            fi            
        fi

        # echo "builders: $builders"
        find $TOOLCHAIN_DIR/ -maxdepth 1 -type d -name "*-*" | while read platBuilder; do
            platBuilder=`basename $platBuilder`
            # echo "platbuilder: $platBuilder"
            export BUILDER_DIR=${PWD}/$platBuilder
            
            if [ "$plat" != "" ]; then
                if [ `echo $platBuilder | grep -c "$plat"` -gt 0 ]; then
                	#echo "build $plat: $platBuilder"
                    build $platBuilder
                    res=$?
                    if [ $res != 0 ]; then
                        echo -e "$RED Failed on $platBuilder, error code: $res $ENDCOLOR"
                        return $res
                    fi                 
                fi
            else
            	#echo "build $platBuilder"
                build $platBuilder
            fi
        done

        popd > /dev/null

    done

    return 0
}

function runcmd()
{   
    echo -e $GREEN $1 "->" $cmd $ENDCOLOR

    $cmd
}

function rungit()
{   
    echo -e $GREEN $1 $ENDCOLOR

    git $push $pull $checkout $branch $param
}   

function runmvn()
{   
    echo -e $GREEN $1 $ENDCOLOR

    if [ "$clean$compile$install$package$run$test$param" != "" ]; then
        mvn $clean $compile $install $package $run $test $param
    fi

    if [ "$release" == "release" ]; then
        echo ""
        echo -e $GREEN Release $1 $ENDCOLOR

        find ./ -name "*provider*.jar" | while read javajarfile; do
            mkdir -p $ALLMAKE_HOME/release/mvn/$1/app
            cp $javajarfile $ALLMAKE_HOME/release/mvn/$1/app/
        done
        
        find ./ -name "*consumer*.jar" | while read javajarfile; do
            mkdir -p $ALLMAKE_HOME/release/mvn/$1/app
            cp $javajarfile $ALLMAKE_HOME/release/mvn/$1/app/
        done    
    fi
}

function rundockercompose()
{
    l_daemon=
    if [ "$daemon" != "" ]; then
        l_daemon=" -d"
    fi

    sudo docker-compose $up $down $l_daemon $version $build $config $create $events $kill $logs $pause $port $ps $pull $restart $rm $run $scale $start $stop $unpause 
}   

function rundockers()
{

    if [ "$help" != "" ]; then

        echo -e " 
        ${ALLMAKE_NAME} docker build              Build or rebuild services
        ${ALLMAKE_NAME} docker config             Validate and view the compose file
        ${ALLMAKE_NAME} docker create             Create services
        ${ALLMAKE_NAME} docker down               Stop and remove containers, networks, images, and volumes
        ${ALLMAKE_NAME} docker events             Receive real time events from containers
        ${ALLMAKE_NAME} docker help               Get help on a command
        ${ALLMAKE_NAME} docker kill               Kill containers
        ${ALLMAKE_NAME} docker logs               View output from containers
        ${ALLMAKE_NAME} docker pause              Pause services
        ${ALLMAKE_NAME} docker port               Print the public port for a port binding
        ${ALLMAKE_NAME} docker ps                 List containers
        ${ALLMAKE_NAME} docker pull               Pulls service images
        ${ALLMAKE_NAME} docker restart            Restart services
        ${ALLMAKE_NAME} docker rm                 Remove stopped containers
        ${ALLMAKE_NAME} docker run                Run a one-off command
        ${ALLMAKE_NAME} docker scale              Set number of containers for a service
        ${ALLMAKE_NAME} docker start              Start services
        ${ALLMAKE_NAME} docker stop               Stop services
        ${ALLMAKE_NAME} docker unpause            Unpause services
        ${ALLMAKE_NAME} docker up                 Create and start containers
        ${ALLMAKE_NAME} docker version            Show the Docker-Compose version information
        "
        exit
    fi

    find ./ -name "docker-compose.yml" -print | sort | while read dockercompose; do

        dockerdir=$(dirname "${dockercompose}")
        #echo $dockerdir
        # echo builders:$builders
        pushd $dockerdir > /dev/null

        #echo $PWD

        # # echo "builders: $builders"
        if [ "$app" != "" ]; then
            if [ $(echo $dockercompose | grep -c "$app") -gt 0 ]; then
                #echo "run $app: $dockercompose"
                rundockercompose

            fi
        else
            #echo "run $dockercompose"
            rundockercompose
        fi

        if [ "$sleep" != "" ]; then
            sleep $sleep
        fi
       
        popd > /dev/null

    done


    return 0
}


function runmvns()
{

    if [ "$help" != "" ]; then

        echo -e " 
        ${ALLMAKE_NAME} mvn clean               Clean project
        ${ALLMAKE_NAME} mvn compile             Compile project
        ${ALLMAKE_NAME} mvn run                 Run project
        ${ALLMAKE_NAME} mvn install             Install to maven repository       
        "
        exit
    fi
    
    find ./ -maxdepth 2 -name "pom.xml" -print | sort | while read mvnproj; do

        mvnprojdir=$(dirname "${mvnproj}")
        #echo $dockerdir
        # echo builders:$builders
        pushd $mvnprojdir > /dev/null

        #echo $PWD
        # # echo "builders: $builders"        
        if [ "$app" != "" ]; then
            if [ $(echo $mvnprojdir | grep -c "$app") -gt 0 ]; then
                #echo "run $app: $dockercompose"
                runmvn $mvnprojdir

            fi
        else
            #echo "run $dockercompose"
            runmvn $mvnprojdir
        fi 
             
       
        popd > /dev/null

    done



    return 0
}

function runcmds()
{

    if [ "$help" != "" ]; then
        echo -e " 
        ${ALLMAKE_NAME} cmd="any unix/linux command line"         
        "
        exit
    fi

    searchType=
    filter=$filter
    if [ $(echo $cmd | grep -c "git") -gt 0 ]; then
        searchType="-type d"
        filter=".git"
    elif [ $(echo $cmd | grep -c "mvn") -gt 0 ]; then
        filter="pom.xml"
        maxdepth=2
    elif [ "$filter" == "" ]; then
        filter="*"
    fi


    depth=
    if [ "$maxdepth" != "" ]; then
        depth="-maxdepth $maxdepth"
    fi
    
    find ./ $depth $searchType -name "$filter" -print | sort | while read proj; do

        projdir=$(dirname "${proj}")
        #echo $dockerdir
        # echo builders:$builders
        pushd $projdir > /dev/null

        #echo $PWD

        # # echo "builders: $builders"
        if [ "$app" != "" ]; then
            if [ $(echo $projdir | grep -c "$app") -gt 0 ]; then
                runcmd $projdir

            fi
        else
            runcmd $projdir
        fi        
       
        popd > /dev/null

    done


    return 0
}

function rungits()
{

    if [ "$help" != "" ]; then

        echo -e " 
        ${ALLMAKE_NAME} git pull                    Git pull
        ${ALLMAKE_NAME} git checkout [branch name]  Git checkout branch            
        "
        exit
    fi

    find ./ -type d -name ".git" -print | sort | while read gitproj; do

        gitprojdir=$(dirname "${gitproj}")
        #echo $dockerdir
        # echo builders:$builders
        pushd $gitprojdir > /dev/null

        #echo $PWD

        # # echo "builders: $builders"
        if [ "$app" != "" ]; then
            if [ $(echo $gitprojdir | grep -c "$app") -gt 0 ]; then
                rungit $gitprojdir

            fi
        else
            rungit $gitprojdir
        fi        
       
        popd > /dev/null

    done


    return 0
}

###############################################################################
# Quit

function quit()
{
    # remove Makefile after built all for keeping it up-to-date

    if [ "${isThirdPartyProject}" == "no" ] && [ "$1" == "Done!" ]; then
    	# echo "remove $PWD/Makefile ..."
        rm -rf Makefile
    fi

    if [ "$1" != "" ]; then
        echo ""
        echo -e "${DARKGREEN}$1${ENDCOLOR}"
        echo ""
    else
        # echo "Exit ... "
        kill -s TERM $$
    fi
    exit
}

###############################################################################
# all make main loop

function mainloop()
{
    echo ""
}

#echo "main loop"
###############################################################################
# Common variables

export LANG=C.UTF-8
export DEVICE_PATH=$DEVICE_PATH
export OS=`uname`
export OS=${OS%_*}

DEP_INSTALL_CMD="sudo apt-get install make rpl"
if [ "$ALLMAKE_HOME" == "" ]; then
    export ALLMAKE_HOME=$KIWI_ROOT
fi

if [ "$OS" == "Darwin" ]; then
    export COLOR_PREFIX="\033"
    DEP_INSTALL_CMD="brew install make rpl"
elif [ "$OS" == "MSYS" ]; then
    DEP_INSTALL_CMD="pacman -S make rpl"    
else
    export COLOR_PREFIX="\e"
fi

export DARKRED="\033[1;31m"
export RED="\033[3;31m"
export DARKGREEN="\033[1;32m"
export GREEN="\033[3;32m"
export DARKYELLOW="\033[1;33m"
export YELLOW="\033[3;33m"
export DARKBLUE="\033[1;34m"
export BLUE="\033[3;34m"
export DARKPURPLE="\033[1;35m"
export PURPLE="\033[3;35m"
export DARKTEAL="\033[1;36m"
export TEAL="\033[3;36m"
export DARKGRAY="\033[1;90m"
export GRAY="\033[3;37m"
export ENDCOLOR="\033[3;0m"
export CANYON=${TEAL}

export E_DARKRED="${COLOR_PREFIX}[1;31m"
export E_RED="${COLOR_PREFIX}[3;31m"
export E_DARKGREEN="${COLOR_PREFIX}[1;32m"
export E_GREEN="${COLOR_PREFIX}[3;32m"
export E_DARKYELLOW="${COLOR_PREFIX}[1;33m"
export E_YELLOW="${COLOR_PREFIX}[3;33m"
export E_DARKBLUE="${COLOR_PREFIX}[1;34m"
export E_BLUE="${COLOR_PREFIX}[3;34m"
export E_DARKPURPLE="${COLOR_PREFIX}[1;35m"
export E_PURPLE="${COLOR_PREFIX}[3;35m"
export E_DARKTEAL="${COLOR_PREFIX}[1;36m"
export E_TEAL="${COLOR_PREFIX}[3;36m"
export E_ENDCOLOR="${COLOR_PREFIX}[3;0m"

export ECHO_OPTION_E=
if [ "$OS" == "MSYS" ]; then
    export ECHO_OPTION_E=-e
fi

###############################################################################
# Show version
function showInstallErrorMessage()
{
    if [ $? != 0 ]; then
        echo -e "$RED Installing ${ALLMAKE_NAME} failed! $ENDCOLOR"
        quit
    fi
}

if [ "$1" == "-i" ] || [ "$1" == "--install" ]; then

    # hasMake=`which make | wc -l`
    # if [ "$hasMake" == "0" ]; then
        $DEP_INSTALL_CMD
    # fi
    
    ETC_PROFILE=/etc/profile 

    hasAllmakeEnv=`cat $ETC_PROFILE | grep "\#allmake-begin"`
    #echo $hasAllmakeEnv
    
    if [ "$hasAllmakeEnv" != "" ]; then
        #echo "replace ..."
        sed -n ":b
$ !{
   N
   b b
   }
$ {
   s|\(\n\#allmake-begin\).*\(\n\)\([[:blank:]]*\)\(\#allmake-end\)|${REPLACEWITH}|
   p
   }" $ETC_PROFILE > /tmp/.profile
   showInstallErrorMessage

   mv /tmp/.profile $ETC_PROFILE
   showInstallErrorMessage
    fi
        #echo "append ..."

        echo "#allmake-begin
export ALLMAKE_HOME=$PWD
export PATH=\$ALLMAKE_HOME/bin:\$PATH
#allmake-end" >> ${ETC_PROFILE}

    #source ${ETC_PROFILE}
    showInstallErrorMessage

    echo -e " $GREEN
    Installed ${ALLMAKE_NAME} successfully!
    $ENDCOLOR"
    exit
fi

###############################################################################
# Show version

if [ "$1" == "-v" ] || [ "$1" == "--version" ]; then
    
    showVersion

    exit
fi

###############################################################################
# Help


if [ "$1" == "-h" ] || [ "$1" == "--help" ]; then
    
    showHelp

    exit    
fi
###############################################################################
# Parse the command line
CMD_LINE=${0##*/} 
while [ "$#" != "0" ]; do
    if [ "$1" == "plat" ]; then
        CMD_LINE="$CMD_LINE $1"
        shift
        plat="$1"
        CMD_LINE="$CMD_LINE $1"
        shift
    fi

    if [ `echo "$1" | grep -c "="` -gt 0 ]; then
        # echo $1
        read name value <<<$(IFS="="; echo $1)
        value=$1
        value=${value#*=}
        # echo name: $name value: $value
        export eval $(echo $name)="$value"

        numOfWord=`echo $value | wc -w`
        if [ $numOfWord -gt 1 ]; then
            CMD_LINE="$CMD_LINE $name='"
            CMD_LINE="$CMD_LINE${value}'"
        else
            CMD_LINE="$CMD_LINE $1"
        fi

        shift
    else
        if [ "$#" != "0" ]; then
            export eval $(echo $1)="$1"
            CMD_LINE="$CMD_LINE $1"
            shift
        fi
    fi

done

###############################################################################
showVersion
###############################################################################
# Init variables
export WOKRING_DIR=$PWD
export CMD_LINE
export configure # not necessary ?
export MAKE_CLEAN=$clean
export MAKE_DISTCLEAN=$distclean
export MAKE_ALL=$all
export MAKE_INSTALL=$install
export RELEASE=$release
export CUSTOM_CFLAGS="${PLAT_CFLAGS} -O0 -g3"
export CUSTOM_LFLAGS="-g"
export SPACE=" "
export TOOLCHAIN_DIR=$ALLMAKE_HOME/toolchain
export PROJECT_NAME=${PWD##*/}
export PROJECT_HOME="../.."
export PREFIX=$prefix
export dateTime=$(date +"%y%m%d")
export user=`whoami`

if [ "$target" != "" ]; then
    export TARGET=$target
fi

if [ "$release" != "" ]; then
    export CUSTOM_CFLAGS="${PLAT_CFLAGS} -O2"
    export CUSTOM_LFLAGS=""
fi

OUTPUT_TYPE="library"
BUILD_LIB=yes
if [ "$lib" != "" ] || [ "$library" != "" ]; then
    BUILD_LIB=yes
    OUTPUT_TYPE="library"
fi
if [ "$app" != "" ] || [ "$bin" != "" ]; then
    BUILD_LIB=no
    OUTPUT_TYPE="binary"
fi

if [ "$buildclean" != "" ]; then
    rm -rf ./build
    echo "[${ALLMAKE_NAME}] build clean ..."
    quit
fi
export BUILD_LIB

LARGS="PLAT_CFLAGS=\"${CUSTOM_CFLAGS}\" PLAT_LFLAGS=\"${CUSTOM_LFLAGS}\" $clean $all $install $print"
BUILD_SH="build.sh"

export isThirdPartyProject=no
if [ -f "Configure" ]; then
    export CONFIG_CMD=Configure
    export isThirdPartyProject=yes
fi

if [ -f "configure" ]; then
    export CONFIG_CMD=configure
    export isThirdPartyProject=yes
fi

export SRC_EXT=cpp
if [ "$ext" != "" ]; then
    export SRC_EXT=$ext
fi
if [ "$c" != "" ]; then
    export SRC_EXT="c"
fi
if [ "$cpp" != "" ]; then
    export SRC_EXT="cpp"
fi

S_PROJECT_NAME=${PROJECT_NAME//-/}
if [ "$SRC_DIR_NAME" == "" ]; then
    SRC_DIR_NAME=src
fi

###############################################################################
# add new platform

if [ "$add" != "" ]; then
    if [ "$app" != "" ]; then
        # allmake add app=vp-sms-provider ver=1.0.0 profile=test ports="9100 9200 9300" template=java inet=eth0
        #o "$app"

        hostIpAddress=$(ifconfig $inet | grep "inet addr" | cut -d ':' -f 2 | cut -d ' ' -f 1)

        portsArray=$(
            for port in $ports
            do
                echo "    - $port:$port"
            done
        )

        #echo $portsArray

        mkdir -p $app/app/config
        mkdir -p $app/app/logs

        cp $ALLMAKE_HOME/templates/$template.amt $app/docker-compose.yml        

        sed -i "s/\${app}/${app}/g; s/\${ver}/${ver}/g; s/\${profile}/${profile}/g; s/\${hostIpAddress}/${hostIpAddress}/g" $app/docker-compose.yml

        rpl -w -q "\${portsArray}" "${portsArray}" $app/docker-compose.yml

        quit "Created app: $app"

    fi

    if [ ! -d build ]; then
        mkdir -p build 
    fi

    if [ "$isThirdPartyProject" == "no" ]; then
        if [ ! -d src ]; then
            mkdir -p src
        fi
        if [ ! -d include ]; then 
            mkdir -p include
        fi

        if [ ! -d "./$SRC_DIR_NAME/tests" ]; then
            mkdir -p ./$SRC_DIR_NAME/tests
        fi

        if [ ! -f src/version.$SRC_EXT ]; then
            updateVersion=yes
        fi

        if [ "$ver" != "" ]; then
            updateVersion=yes                
        else
            ver=1.0.0
        fi

        #echo "$updateVersion: $ver"
        createVersionSource $updateVersion
        # if [ "$updateVersion" == "yes" ]; then
        #     quit "Changed app version to $ver"
        # fi        
    fi

    createWinApi

   	createSourceCode
    userComfirmed=$?
    if [ -f build/Makefile ]; then
        if [ $userComfirmed == 2 ]; then
            quit "Added $test"
        elif [ $userComfirmed == 1 ]; then
            quit "Cancelled"
        fi
    fi
elif [ "$cmd" != "" ]; then

    runcmds
    exit

elif [ "$git" != "" ]; then

    rungits
    exit
elif [ "$mvn" != "" ]; then

    runmvns
    exit
elif [ "$docker" != "" ]; then

    rundockers
    exit

elif [ "$update" != "" ]; then

    # update version
    if [ "$ver" != "" ]; then
        sed -i "s/REVERSION.*\\\"/REVERSION := \\\\\"${ver}\\\\\"/g" build/Makefile
        quit "version $ver is up to date"
    fi

else

    if [ "$isThirdPartyProject" == "no" ] && [ ! -f ./build/Makefile ]; then
        echo "Makefile not found"
        showHelp
        exit
    fi     

fi

if [ "$isThirdPartyProject" == "no" ]; then
    createCommonMakefile
fi

###############################################################################
# For QT support
EXPORT_USE_QT=
if [ "$qt" == "qt" ]; then
    EXPORT_USE_QT="export USE_QT := yes"
fi

EXPORT_QT_MKSPECS=
if [ "$mkspecs" != "" ]; then
    EXPORT_QT_MKSPECS="export QT_MKSPECS_DIR := ${mkspecs}"
fi

EXPORT_QT_VER=
if [ "$qtver" != "" ]; then
    EXPORT_QT_VER="export QT_VER := ${qtver}"
fi

if [ "$maxdepth" == "" ]; then
    maxdepth=1
fi

###############################################################################
# parse all source files, filter out the source file without main function

# srcFindFilter="*$bin*.c*"
# if [ "$bin" == "bin" ]; then
#     srcFindFilter="*.c*"
# fi

# find ./$SRC_DIR_NAME -name "*.c*" -exec grep -rn "\<main\>[ ()]" {} \; -print | grep \/ | { while read binPath; do
#         echo src:$binPath
#         binPath=${binPath%:*}
#         binSrc=${binPath##*\/}
#         srcFileFilterLnes=
#         isVaildSource=`echo $binSrc | grep -c ".c"`
#         if [ "$isVaildSource" == "1" ]; then
#             echo $isVaildSource
#             gcc -w -fpreprocessed -dD -E $binPath | grep main
#             isVaildSource=`gcc -w -fpreprocessed -dD -E $binPath | grep -rn "\<main\>[ ()]" | wc -l`
#             echo $isVaildSource
#             if [ "$isVaildSource" != "0" ]; then
#                 echo "${SPACE}${binPath}"
#                 #((count++))
#             fi    
#         fi
#     done
# }


result=
if [ -d ./$SRC_DIR_NAME ]; then

    result=$(find ./$SRC_DIR_NAME -name "*.c*" -exec grep -rn "\<main\>[ ()]" {} \; -print | grep \/ | { while read binPath; do
        
        binPath=${binPath%:*}
        binSrc=${binPath##*\/}
        srcFileFilterLnes=

        isVaildSource=`echo $binSrc | grep -c ".c"`
        if [ "$isVaildSource" == "1" ]; then
            isVaildSource=`gcc -w -fpreprocessed -dD -E $binPath | grep -rn "\<main\>[ ()]" | wc -l`
            if [ "$isVaildSource" != "0" ]; then
                echo ${SPACE}${binPath}
                #((count++))
            fi    
        fi
    done
        #echo ":"
        #echo -n $count
    })

fi

# get the result
srcFileFilter=${result//.\/$SRC_DIR_NAME\//}
srcFileFilter=`echo $srcFileFilter | xargs | sed "s/ ---- /\n---- /g"`
srcFileFilter=${SPACE}${srcFileFilter=} # level space at the beginning for filter substitution to avoid error

#echo ${srcFileFilter}
srcFileCount=`echo $srcFileFilter | wc -w`
#echo $srcFileCount

###############################################################################
# build loop
#echo "$CMD_LINE"

if [ "$bin" != "" ] && [ "$add" == "" ]; then
    # echo "build binary"
    if [ $srcFileCount == 0 ]; then
        showWarning "No source file found!"
        quit
    fi

    export TARGET=$PROJECT_NAME
    if [ $srcFileCount == 1 ];then
        if [ "$bin" != "" ]; then
            if [ "$bin" != "bin" ]; then
                export TARGET=
            fi
        fi
    fi

    firstRun=yes
    #find ./$SRC_DIR_NAME -name "$srcFindFilter" -exec grep -rn "\<main\>[ ()]" {} \; -print | grep \/ | while read binPath; do
    for binPath in $result
    do    
        #echo "-----------------------------------------"
        #echo $binPath
        #echo "-----------------------------------------"
        binPath=${binPath%:*}
        #binSrc=${binPath##*\/}
        binSrc=${binPath//.\/$SRC_DIR_NAME\//}

        #echo binPath: $binPath
        # echo binSrc: $binSrc
        isVaildSource=true
        if [ "$bin" != "bin" ] && [ $(echo $binSrc | grep $bin | wc -l) == 0 ]; then
            isVaildSource=false
        fi

        if [ $isVaildSource == true ]; then
            binSrcName=${binSrc%.*}
            if [ `echo $binPath | grep -c "tests/"` -gt 0 ]; then
                export TARGET=${binSrcName}
            else
                export TARGET=$PROJECT_NAME
            fi
            l_srcFileFilter=${srcFileFilter//${SPACE}${binSrc}/}
            #echo src!filterout: ${binSrc}!${l_srcFileFilter}

            # final build ...         
            buildall "${l_srcFileFilter}"
            res=$?
            if [ $res != 0 ]; then
                #echo -e "$RED Build bin failed! $ENDCOLOR"
                quit
            fi
        fi

        # only the first loop need to be clean
        if [ "$firstRun" == "yes" ]; then
            firstRun=no
            clean=
        fi

    done
else
    # echo "build ..."
    # echo ${srcFileFilter}: $(echo ${srcFileFilter} | grep "tests/" | wc -l)
    if [ $srcFileCount -gt 1 ] || [ $(echo ${srcFileFilter} | grep "tests" | wc -l) != 0  ]; then
        buildall "${srcFileFilter}"
    else
        buildall
    fi

    res=$?
    if [ $res != 0 ]; then
        #echo -e "$RED Build failed! $ENDCOLOR"
        quit
    fi
fi

###############################################################################
# Finished all

# echo "quit ..."
quit "Done!"

